<html>
<head>
<title>Operator</title>
<link rel="stylesheet" type="text/css" href="style.css">
<meta charset="UTF-8">
</head>
<body>
<div id="fb_body_wrapper">
<div id="fb_tab">
<div id="fb_tab_l">Operator</div>
<div id="fb_tab_r">&nbsp;<a href="00index.html"><img src="images/fblogo_mini.gif" /></a></div> 
</div> 
<div id="fb_pg_wrapper">
<div id="fb_pg_body">
	Declares or defines an overloaded operator.<br \>
<br \>
<div class="fb_sect_title">Syntax</div><div class="fb_sect_cont"><tt><br \>
{ <a href="KeyPgType.html">Type</a> | <a href="KeyPgClass.html">Class</a> | <a href="KeyPgUnion.html">Union</a> } <i>typename</i><br \>
<div class="fb_indent"><a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpCast.html">Cast</a> () [ <a href="KeyPgByrefFunction.html">ByRef</a> ] <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpAt.html">@</a> () [ <a href="KeyPgByrefFunction.html">ByRef</a> ] <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> <a href="KeyPgPtr.html">Ptr</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <i>assignment_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> )<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpPtrIndex.html">[]</a> ( <i>index</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) [ <a href="KeyPgByrefFunction.html">ByRef</a> ] <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpNewOverload.html">New</a> ( <i>size</i> <a href="KeyPgAs.html">As</a> <a href="KeyPgUinteger.html">UInteger</a> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpNewOverload.html">New</a>[] ( <i>size</i> <a href="KeyPgAs.html">As</a> <a href="KeyPgUinteger.html">UInteger</a> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpDeleteOverload.html">Delete</a> ( <i>buf</i>  <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a> )<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpDeleteOverload.html">Delete</a>[] ( <i>buf</i>  <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a> )<br \>
</div>End { <a href="KeyPgType.html">Type</a> | <a href="KeyPgClass.html">Class</a> | <a href="KeyPgUnion.html">Union</a> }<br \>
<br \>
{ <a href="KeyPgType.html">Type</a> | <a href="KeyPgClass.html">Class</a> | <a href="KeyPgUnion.html">Union</a> } <i>typename</i><br \>
<div class="fb_indent"><a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpFor.html">For</a> ()<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpFor.html">For</a> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>stp</i> <a href="KeyPgAs.html">As</a> <i>typename</i> )<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpStep.html">Step</a> ()<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpStep.html">Step</a> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>stp</i> <a href="KeyPgAs.html">As</a> <i>typename</i> )<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpNext.html">Next</a> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>cond</i> <a href="KeyPgAs.html">As</a> <i>typename</i> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgInteger.html">Integer</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpNext.html">Next</a> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>cond</i> <a href="KeyPgAs.html">As</a> <i>typename</i>, [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>stp</i> <a href="KeyPgAs.html">As</a> <i>typename</i> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgInteger.html">Integer</a><br \>
</div>End { <a href="KeyPgType.html">Type</a> | <a href="KeyPgClass.html">Class</a> | <a href="KeyPgUnion.html">Union</a> }<br \>
<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <i>unary_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <i>binary_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>lhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a>, [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgOpCast.html">Cast</a> () [ <a href="KeyPgByrefFunction.html">ByRef</a> ] <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> [ <a href="KeyPgExport.html">Export</a> ]<br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgOpAt.html">@</a> () [ <a href="KeyPgByrefFunction.html">ByRef</a> ] <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> <a href="KeyPgPtr.html">Ptr</a> [ <a href="KeyPgExport.html">Export</a> ]<br \>
<b>Operator</b> <i>typename</i>.<i>assignment_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) [ <a href="KeyPgExport.html">Export</a> ]<br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgOpPtrIndex.html">[]</a> ( <i>index</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) [ <a href="KeyPgByrefFunction.html">ByRef</a> ] <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> [ <a href="KeyPgExport.html">Export</a> ]<br \>
<b>Operator</b> <i>unary_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> [ <a href="KeyPgExport.html">Export</a> ]<br \>
<b>Operator</b> <i>binary_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>lhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a>, [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> [ <a href="KeyPgExport.html">Export</a> ]<br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgOpNewOverload.html">New</a> ( <i>size</i> as uinteger ) <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a> [ <a href="KeyPgExport.html">Export</a> ]<br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgOpNewOverload.html">New</a>[] ( <i>size</i> <a href="KeyPgAs.html">As</a> <a href="KeyPgUinteger.html">UInteger</a> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a> [ <a href="KeyPgExport.html">Export</a> ]<br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgOpDeleteOverload.html">Delete</a> ( <i>buf</i>  <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a> ) [ <a href="KeyPgExport.html">Export</a> ]<br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgOpDeleteOverload.html">Delete</a>[] ( <i>buf</i>  <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a> ) [ <a href="KeyPgExport.html">Export</a> ]<br \>
</tt><br \>
</div><div class="fb_sect_title">Parameters</div><div class="fb_sect_cont"><br \>
<tt><i>typename</i></tt> <br \>
<div class="fb_indent">Name of the <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt>, <tt><a href="KeyPgUnion.html">Union</a></tt>, or <tt><a href="KeyPgEnum.html">Enum</a></tt>.<br \>
</div><tt><i>assignment_op</i></tt> <br \>
<div class="fb_indent"><tt>let += -= *= &= /= \= mod= shl= shr= and= or= xor= imp= eqv= ^=</tt><br \>
</div><tt><i>unary_op</i></tt><br \>
<div class="fb_indent"><tt>- not * -&gt; abs sgn fix frac int exp log sin asin cos acos tan atn len sqr</tt><br \>
</div><tt><i>binary_op</i></tt><br \>
<div class="fb_indent"><tt>+ - * & / \ mod shl shr and or xor imp eqv ^ = &lt;&gt; &lt; &gt; &lt;= &gt;=</tt><br \>
<br \>
</div></div><div class="fb_sect_title">Description</div><div class="fb_sect_cont"><br \>
The built in operators like <tt>=</tt>, <tt>+</tt>, and <tt>cast</tt> have predefined behaviors when used in expressions.  These operators can be overloaded to do something other than predefined operations when at least one of the arguments to the operator is a <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt>, <tt><a href="KeyPgEnum.html">Enum</a></tt>, or <tt><a href="KeyPgUnion.html">Union</a></tt> data type.<br \>
<br \>
Operators are just functions.  The operator '+' has functionality like <tt>Function Plus( A as DataType, B as DataType ) as DataType</tt>.  See <i><a href="ProPgOperatorOverloading.html">Operator Overloading</a></i> for more information.  Operators can be overloaded to accept different data types as parameters.  The <tt><a href="KeyPgOpCast.html">Cast</a></tt> Operator is the only operator (or function) that can be declared multiple times when only the return type differs, but not the same as the <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt>, or <tt><a href="KeyPgUnion.html">Union</a></tt> it is declared in (for not explicit usage, the compiler may decide which cast overload to call based on how the object is used).<br \>
<br \>
Non-static operator members are declared inside the <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt>, or <tt><a href="KeyPgUnion.html">Union</a></tt>.  Global operators are declared outside.  All operator definitions (procedure bodies) must appear outside.<br \>
<br \>
<tt><b>Let</b></tt>, <tt><b>Cast</b></tt>, and other assignment operators must be declared inside the <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt>, or <tt><a href="KeyPgUnion.html">Union</a></tt>.  As all non-static member procedures, they have passed a hidden <tt><a href="KeyPgThis.html">This</a></tt> parameter.<br \>
<br \>
Unary operators must be declared outside the <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt>, or <tt><a href="KeyPgUnion.html">Union</a></tt> and have a return data type explicitly declared.  Unary operators can be overloaded to return any valid data type, except for <tt><a href="KeyPgOpPtrMemberAccess.html">Operator -&gt; (Pointer To Member Access)</a></tt> which must return a <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt>, or <tt><a href="KeyPgUnion.html">Union</a></tt> data type.<br \>
<br \>
Binary operators must be declared outside the <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt>, or <tt><a href="KeyPgUnion.html">Union</a></tt> and have a return data type explicitly declared.  Binary operators can be overloaded with valid data types, including for relational operators, which can also return any valid data type.<br \>
<br \>
<tt><a href="KeyPgLet.html">Let</a></tt> refers to the assignment operator, as in <tt>LET a=b</tt>. The <tt><a href="KeyPgLet.html">Let</a></tt> keyword is omitted in common practice, and is not allowed in the <i><a href="CompilerOptlang.html">-lang fb</a></i> dialect.  However, <tt><a href="KeyPgOpLetlist.html">Let()</a></tt> can be used to assign the fields of a UDT to multiple variables.<br \>
<br \>
See <tt><a href="KeyPgOpFor.html">For</a></tt>, <tt><a href="KeyPgOpStep.html">Step</a></tt>, and <tt><a href="KeyPgOpNext.html">Next</a></tt> for more information on overloading the <tt><a href="KeyPgFornext.html">For..Next</a></tt> statement for use with user defined types.<br \>
<br \>
Member operators <tt><b>New</b></tt>, <tt><b>New[]</b></tt>, <tt><b>Delete</b></tt>, and <tt><b>Delete[]</b></tt> are always static, even if not explicitly declared (<tt><a href="KeyPgStaticMember.html">Static</a></tt> keyword is unnecessary but allowed).<br \>
<br \>
</div><div class="fb_sect_title">Example</div><div class="fb_sect_cont"><br \>
<tt><div class="freebasic">
<span class="com">''&nbsp;operator1.bas</span><br />
<br />
<span class="key">Type</span>&nbsp;<span class="wrd">Vector2D</span><br />
&nbsp;&nbsp;<span class="key">As</span>&nbsp;<span class="key">Single</span>&nbsp;<span class="wrd">x</span><span class="oth">,</span>&nbsp;<span class="wrd">y</span><br />
<br />
&nbsp;&nbsp;<span class="com">''&nbsp;Return&nbsp;a&nbsp;string&nbsp;containing&nbsp;the&nbsp;vector&nbsp;data.</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="key">Cast</span><span class="oth">()</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">String</span><br />
<br />
&nbsp;&nbsp;<span class="com">''&nbsp;Multiply&nbsp;the&nbsp;vector&nbsp;by&nbsp;a&nbsp;scalar.</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="oth">*=</span>&nbsp;<span class="oth">(</span>&nbsp;<span class="key">ByVal</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Single</span>&nbsp;<span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="com">''&nbsp;Allow&nbsp;two&nbsp;vectors&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;be&nbsp;added&nbsp;together.</span><br />
<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="oth">(</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">lhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span><span class="oth">,</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span><br />
<br />
<span class="com">''&nbsp;Return&nbsp;the&nbsp;modulus&nbsp;(single)&nbsp;of&nbsp;the&nbsp;vector&nbsp;using&nbsp;the&nbsp;overloaded&nbsp;operator&nbsp;abs().</span><br />
<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="key">Abs</span>&nbsp;<span class="oth">(</span>&nbsp;&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Single</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="wrd">Vector2D.cast</span>&nbsp;<span class="oth">()</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">String</span><br />
&nbsp;&nbsp;<span class="key">Return</span>&nbsp;<span class="quo">&quot;(&quot;</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="key">Str</span><span class="oth">(</span><span class="wrd">x</span><span class="oth">)</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="quo">&quot;,&nbsp;&quot;</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="key">Str</span><span class="oth">(</span><span class="wrd">y</span><span class="oth">)</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="quo">&quot;)&quot;</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="wrd">Vector2D.</span><span class="oth">*=</span>&nbsp;<span class="oth">(</span>&nbsp;<span class="key">ByVal</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Single</span>&nbsp;<span class="oth">)</span><br />
&nbsp;&nbsp;<span class="wrd">This.x</span>&nbsp;<span class="oth">*=</span>&nbsp;<span class="wrd">rhs</span><br />
&nbsp;&nbsp;<span class="wrd">This.y</span>&nbsp;<span class="oth">*=</span>&nbsp;<span class="wrd">rhs</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="oth">(</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">lhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span><span class="oth">,</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span><br />
&nbsp;&nbsp;<span class="key">Return</span>&nbsp;<span class="key">Type</span><span class="oth">&lt;</span><span class="wrd">Vector2D</span><span class="oth">&gt;(</span>&nbsp;<span class="wrd">lhs.x</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">rhs.x</span><span class="oth">,</span>&nbsp;<span class="wrd">lhs.y</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">rhs.y</span>&nbsp;<span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="key">Abs</span>&nbsp;<span class="oth">(</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Single</span><br />
&nbsp;&nbsp;<span class="key">Return</span>&nbsp;<span class="key">Sqr</span><span class="oth">(</span>&nbsp;<span class="wrd">rhs.x</span>&nbsp;<span class="oth">*</span>&nbsp;<span class="wrd">rhs.x</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">rhs.y</span>&nbsp;<span class="oth">*</span>&nbsp;<span class="wrd">rhs.y</span>&nbsp;<span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="wrd">a</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">Type</span><span class="oth">&lt;</span><span class="wrd">Vector2D</span><span class="oth">&gt;(</span>&nbsp;<span class="num">1.2</span><span class="oth">,</span>&nbsp;<span class="num">3.4</span>&nbsp;<span class="oth">)</span><br />
<span class="key">Dim</span>&nbsp;<span class="wrd">b</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">Type</span><span class="oth">&lt;</span><span class="wrd">Vector2D</span><span class="oth">&gt;(</span>&nbsp;<span class="num">8.9</span><span class="oth">,</span>&nbsp;<span class="num">6.7</span>&nbsp;<span class="oth">)</span><br />
<span class="key">Dim</span>&nbsp;<span class="wrd">c</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">Type</span><span class="oth">&lt;</span><span class="wrd">Vector2D</span><span class="oth">&gt;(</span>&nbsp;<span class="num">4.3</span><span class="oth">,</span>&nbsp;<span class="num">5.6</span>&nbsp;<span class="oth">)</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="quo">&quot;a&nbsp;=&nbsp;&quot;</span><span class="oth">;</span>&nbsp;<span class="wrd">a</span><span class="oth">,</span>&nbsp;<span class="quo">&quot;abs(a)&nbsp;=&quot;</span><span class="oth">;</span>&nbsp;<span class="key">Abs</span><span class="oth">(</span>&nbsp;<span class="wrd">a</span>&nbsp;<span class="oth">)</span><br />
<span class="key">Print</span>&nbsp;<span class="quo">&quot;b&nbsp;=&nbsp;&quot;</span><span class="oth">;</span>&nbsp;<span class="wrd">b</span><span class="oth">,</span>&nbsp;<span class="quo">&quot;abs(b)&nbsp;=&quot;</span><span class="oth">;</span>&nbsp;<span class="key">Abs</span><span class="oth">(</span>&nbsp;<span class="wrd">b</span>&nbsp;<span class="oth">)</span><br />
<span class="key">Print</span>&nbsp;<span class="quo">&quot;a&nbsp;+&nbsp;b&nbsp;=&nbsp;&quot;</span><span class="oth">;</span>&nbsp;<span class="wrd">a</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">b</span><span class="oth">,</span>&nbsp;<span class="quo">&quot;abs(a+b)&nbsp;=&quot;</span><span class="oth">;</span>&nbsp;<span class="key">Abs</span><span class="oth">(</span>&nbsp;<span class="wrd">a</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">b</span>&nbsp;<span class="oth">)</span><br />
<span class="key">Print</span>&nbsp;<span class="quo">&quot;c&nbsp;=&nbsp;&quot;</span><span class="oth">;</span>&nbsp;<span class="wrd">c</span><span class="oth">,</span>&nbsp;<span class="quo">&quot;abs(c)&nbsp;=&quot;</span><span class="oth">;</span>&nbsp;<span class="key">Abs</span><span class="oth">(</span>&nbsp;<span class="wrd">c</span>&nbsp;<span class="oth">)</span><br />
<span class="key">Print</span>&nbsp;<span class="quo">&quot;'c&nbsp;*=&nbsp;3'&quot;</span><br />
<span class="wrd">c</span>&nbsp;<span class="oth">*=</span>&nbsp;<span class="num">3</span><br />
<span class="key">Print</span>&nbsp;<span class="quo">&quot;c&nbsp;=&nbsp;&quot;</span><span class="oth">;</span>&nbsp;<span class="wrd">c</span><span class="oth">,</span>&nbsp;<span class="quo">&quot;abs(c)&nbsp;=&quot;</span><span class="oth">;</span>&nbsp;<span class="key">Abs</span><span class="oth">(</span>&nbsp;<span class="wrd">c</span>&nbsp;<span class="oth">)</span><br />
</div></tt><br />
<br \>
Small use case of the operator "[]": simplest smart pointers for byte buffers.<br \>
<tt><div class="freebasic">
<span class="com">''&nbsp;operator3.bas</span><br />
<br />
<span class="com">''&nbsp;A&nbsp;smart&nbsp;pointer&nbsp;is&nbsp;an&nbsp;object&nbsp;which&nbsp;behaves&nbsp;like&nbsp;a&nbsp;pointer&nbsp;but&nbsp;does&nbsp;more&nbsp;than&nbsp;a&nbsp;pointer:</span><br />
<span class="com">''&nbsp;-&nbsp;This&nbsp;object&nbsp;is&nbsp;flexible&nbsp;as&nbsp;a&nbsp;pointer&nbsp;and&nbsp;has&nbsp;the&nbsp;advantage&nbsp;of&nbsp;being&nbsp;an&nbsp;object,</span><br />
<span class="com">''&nbsp;&nbsp;&nbsp;like&nbsp;constructor&nbsp;and&nbsp;destructor&nbsp;called&nbsp;automatically.</span><br />
<span class="com">''&nbsp;-&nbsp;Therefore,&nbsp;the&nbsp;destructor&nbsp;of&nbsp;the&nbsp;smart&nbsp;pointer&nbsp;will&nbsp;be&nbsp;automatically&nbsp;called</span><br />
<span class="com">''&nbsp;&nbsp;&nbsp;when&nbsp;this&nbsp;object&nbsp;goes&nbsp;out&nbsp;of&nbsp;scope,&nbsp;and&nbsp;it&nbsp;will&nbsp;delete&nbsp;the&nbsp;user&nbsp;pointer.</span><br />
<br />
<span class="com">''&nbsp;Example&nbsp;of&nbsp;simplest&nbsp;smart&nbsp;pointers&nbsp;for&nbsp;byte&nbsp;buffers:</span><br />
<span class="com">''&nbsp;-&nbsp;Constructor&nbsp;and&nbsp;destructor&nbsp;allow&nbsp;to&nbsp;allocate,&nbsp;deallocate,&nbsp;and&nbsp;resize&nbsp;the&nbsp;byte&nbsp;buffer.</span><br />
<span class="com">''&nbsp;-&nbsp;Pointer&nbsp;index&nbsp;operator&nbsp;allows&nbsp;to&nbsp;access&nbsp;buffer&nbsp;elements.</span><br />
<span class="com">''&nbsp;-&nbsp;Copy-constructor&nbsp;and&nbsp;let-operator&nbsp;are&nbsp;just&nbsp;declared&nbsp;in&nbsp;private&nbsp;section,</span><br />
<span class="com">''&nbsp;&nbsp;&nbsp;in&nbsp;order&nbsp;to&nbsp;disallow&nbsp;copy&nbsp;construction&nbsp;and&nbsp;any&nbsp;assignment.</span><br />
<br />
<span class="key">Type</span>&nbsp;<span class="wrd">smartByteBuffer</span><br />
&nbsp;&nbsp;<span class="key">Public</span><span class="oth">:</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span>&nbsp;<span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">size</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">UInteger</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">0</span><span class="oth">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="oth">[]</span>&nbsp;<span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">index</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">UInteger</span><span class="oth">)</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Byte</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Destructor</span>&nbsp;<span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Private</span><span class="oth">:</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span>&nbsp;<span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">smartByteBuffer</span><span class="oth">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="key">Let</span>&nbsp;<span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">smartByteBuffer</span><span class="oth">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Byte</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="wrd">psbb</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Constructor</span>&nbsp;<span class="wrd">smartByteBuffer</span>&nbsp;<span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">size</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">UInteger</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">0</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="wrd">This.destructor</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">If</span>&nbsp;<span class="wrd">size</span>&nbsp;<span class="oth">&gt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="key">Then</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="wrd">This.psbb</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">New</span>&nbsp;<span class="key">Byte</span><span class="oth">[</span><span class="wrd">size</span><span class="oth">]</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;Byte&nbsp;buffer&nbsp;allocated&quot;</span><br />
&nbsp;&nbsp;<span class="key">End</span>&nbsp;<span class="key">If</span><br />
<span class="key">End</span>&nbsp;<span class="key">Constructor</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="wrd">smartByteBuffer.</span><span class="oth">[]</span>&nbsp;<span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">index</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">UInteger</span><span class="oth">)</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Byte</span><br />
&nbsp;&nbsp;<span class="key">Return</span>&nbsp;<span class="wrd">This.psbb</span><span class="oth">[</span><span class="wrd">index</span><span class="oth">]</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Destructor</span>&nbsp;<span class="wrd">smartByteBuffer</span>&nbsp;<span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">If</span>&nbsp;<span class="wrd">This.psbb</span>&nbsp;<span class="oth">&gt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="key">Then</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Delete</span><span class="oth">[]</span>&nbsp;<span class="wrd">This.psbb</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="wrd">This.psbb</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">0</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;Byte&nbsp;buffer&nbsp;deallocated&quot;</span><br />
&nbsp;&nbsp;<span class="key">End</span>&nbsp;<span class="key">If</span><br />
<span class="key">End</span>&nbsp;<span class="key">Destructor</span><br />
<br />
<span class="key">Scope</span><br />
&nbsp;&nbsp;<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">smartByteBuffer</span>&nbsp;<span class="wrd">sbb</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">smartByteBuffer</span><span class="oth">(</span><span class="num">256</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">For</span>&nbsp;<span class="wrd">I</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="key">To</span>&nbsp;<span class="num">255</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="wrd">sbb</span><span class="oth">[</span><span class="wrd">I</span><span class="oth">]</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">I</span>&nbsp;<span class="oth">-</span>&nbsp;<span class="num">128</span><br />
&nbsp;&nbsp;<span class="key">Next</span>&nbsp;<span class="wrd">I</span><br />
&nbsp;&nbsp;<span class="key">Print</span><br />
&nbsp;&nbsp;<span class="key">For</span>&nbsp;<span class="wrd">I</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="key">To</span>&nbsp;<span class="num">255</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="key">Using</span>&nbsp;<span class="quo">&quot;#####&quot;</span><span class="oth">;</span>&nbsp;<span class="wrd">sbb</span><span class="oth">[</span><span class="wrd">I</span><span class="oth">];</span><br />
&nbsp;&nbsp;<span class="key">Next</span>&nbsp;<span class="wrd">I</span><br />
&nbsp;&nbsp;<span class="key">Print</span><br />
<span class="key">End</span>&nbsp;<span class="key">Scope</span><br />
</div></tt><br />
</div><div class="fb_sect_title">Dialect Differences</div><div class="fb_sect_cont"><br \>
<ul><li> Only available in the <i><a href="CompilerOptlang.html">-lang fb</a></i> dialect.<br \>
<br \>
</ul></div><div class="fb_sect_title">See also</div><div class="fb_sect_cont"><br \>
<ul><li> <tt><a href="KeyPgClass.html">Class</a></tt><br \>
<li> <tt><a href="KeyPgUnion.html">Union</a></tt><br \>
<li> <tt><a href="KeyPgType.html">Type</a></tt><br \>
<li> <a href="ProPgDataConversion.html">Coercion and Conversion</a><br \>
<br \>
</ul></div>
</div>
</div> 
</div> 
</body>
</html>
