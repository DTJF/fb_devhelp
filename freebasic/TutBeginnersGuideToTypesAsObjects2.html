<html>
<head>
<title>Beginners Guide to Types as Objects (Part 2)</title>
<link rel="stylesheet" type="text/css" href="style.css">
<meta charset="UTF-8">
</head>
<body>
<div id="fb_body_wrapper">
<div id="fb_tab">
<div id="fb_tab_l">Beginners Guide to Types as Objects (Part 2)</div>
<div id="fb_tab_r">&nbsp;<a href="00index.html"><img src="images/fblogo_mini.gif" /></a></div> 
</div> 
<div id="fb_pg_wrapper">
<div id="fb_pg_body">
	<br \>
<b>Introduction.</b><br \>
<br \>
Welcome to the second part of the tutorial, In this part I assume that you have read through Part 1, tried the examples, and experimented with some tests of your own.  I'll now cover some topics that I didn't include in Part 1.<br \>
<br \>
<b>Indexed property.</b><br \>
<br \>
An indexed property is a property that behaves like an array, except that like in the case of a regular property, a function gets called when you access it.  I'll start with a very short example just to show the syntax.<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">foo</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Property</span>&nbsp;<span class="wrd">bar</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">index</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">,</span>&nbsp;<span class="key">ByVal</span>&nbsp;<span class="wrd">value</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Property</span>&nbsp;<span class="wrd">bar</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">index</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
&nbsp;&nbsp;<span class="wrd">dummy</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span>&nbsp;<br />
<br />
<span class="key">Property</span>&nbsp;<span class="wrd">foo.bar</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">index</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">,</span>&nbsp;<span class="key">ByVal</span>&nbsp;<span class="wrd">value</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;Property&nbsp;set,&nbsp;index=&quot;</span>&nbsp;<span class="oth">&amp;</span>&nbsp;<span class="wrd">index</span>&nbsp;<span class="oth">&amp;</span>&nbsp;<span class="quo">&quot;,&nbsp;value=&quot;</span>&nbsp;<span class="oth">&amp;</span>&nbsp;<span class="wrd">value</span>&nbsp;<br />
<span class="key">End</span>&nbsp;<span class="key">Property</span><br />
<br />
<span class="key">Property</span>&nbsp;<span class="wrd">foo.bar</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">index</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;Property&nbsp;get,&nbsp;index=&quot;</span>&nbsp;<span class="oth">&amp;</span>&nbsp;<span class="wrd">index</span><br />
&nbsp;&nbsp;<span class="key">Property</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">0</span><br />
<span class="key">End</span>&nbsp;<span class="key">Property</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="wrd">baz</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span><br />
<br />
<span class="wrd">baz.bar</span><span class="oth">(</span><span class="num">0</span><span class="oth">)</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">42</span><br />
<span class="key">Print</span>&nbsp;<span class="wrd">baz.bar</span><span class="oth">(</span><span class="num">0</span><span class="oth">)</span><br />
</div></tt><br />
<br \>
As you can see, the declaration for our indexed property is very similar to a regular one, except this time we add an argument for the index.  I include a dummy integer member, because a type must have at least one data member.  As you can see, the property is then used with (0), to denote we want to get/set the zeroth index, just the same as we would for an ordinary array.  Now I'll show you a slightly more useful example, and I will describe it:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">foo</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">num_elements</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Destructor</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Property</span>&nbsp;<span class="wrd">bar</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">index</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">,</span>&nbsp;<span class="key">ByVal</span>&nbsp;<span class="wrd">value</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Property</span>&nbsp;<span class="wrd">bar</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">index</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<span class="key">Private</span><span class="oth">:</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="key">Ptr</span><br />
&nbsp;&nbsp;<span class="wrd">size</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span>&nbsp;<br />
<br />
<span class="key">Constructor</span>&nbsp;<span class="wrd">foo</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">num_elements</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">CAllocate</span><span class="oth">(</span><span class="wrd">num_elements</span>&nbsp;<span class="oth">*</span>&nbsp;<span class="key">SizeOf</span><span class="oth">(</span><span class="key">Integer</span><span class="oth">))</span><br />
&nbsp;&nbsp;<span class="wrd">size</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">num_elements</span><br />
<span class="key">End</span>&nbsp;<span class="key">Constructor</span><br />
<br />
<span class="key">Destructor</span>&nbsp;<span class="wrd">foo</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Deallocate</span><span class="oth">(</span><span class="wrd">x</span><span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Destructor</span><br />
<br />
<span class="key">Property</span>&nbsp;<span class="wrd">foo.bar</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">index</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">,</span>&nbsp;<span class="key">ByVal</span>&nbsp;<span class="wrd">value</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">If</span>&nbsp;<span class="oth">(</span><span class="wrd">index</span>&nbsp;<span class="oth">&gt;=</span>&nbsp;<span class="num">0</span><span class="oth">)</span>&nbsp;<span class="key">And</span>&nbsp;<span class="oth">(</span><span class="wrd">index</span>&nbsp;<span class="oth">&lt;</span>&nbsp;<span class="wrd">size</span><span class="oth">)</span>&nbsp;<span class="key">Then</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="wrd">x</span><span class="oth">[</span><span class="wrd">index</span><span class="oth">]</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">value</span><br />
&nbsp;&nbsp;<span class="key">Else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Error</span>&nbsp;<span class="num">6</span><br />
&nbsp;&nbsp;<span class="key">End</span>&nbsp;<span class="key">If</span><br />
<span class="key">End</span>&nbsp;<span class="key">Property</span><br />
<br />
<span class="key">Property</span>&nbsp;<span class="wrd">foo.bar</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">index</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
&nbsp;&nbsp;<span class="key">If</span>&nbsp;<span class="oth">(</span><span class="wrd">index</span>&nbsp;<span class="oth">&gt;=</span>&nbsp;<span class="num">0</span><span class="oth">)</span>&nbsp;<span class="key">And</span>&nbsp;<span class="oth">(</span><span class="wrd">index</span>&nbsp;<span class="oth">&lt;</span>&nbsp;<span class="wrd">size</span><span class="oth">)</span>&nbsp;<span class="key">Then</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Property</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">x</span><span class="oth">[</span><span class="wrd">index</span><span class="oth">]</span><br />
&nbsp;&nbsp;<span class="key">Else</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Error</span>&nbsp;<span class="num">6</span><br />
&nbsp;&nbsp;<span class="key">End</span>&nbsp;<span class="key">If</span><br />
<span class="key">End</span>&nbsp;<span class="key">Property</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="wrd">baz</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">foo</span><span class="oth">(</span><span class="num">10</span><span class="oth">)</span><br />
<br />
<span class="wrd">baz.bar</span><span class="oth">(</span><span class="num">1</span><span class="oth">)</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">42</span><br />
<span class="key">Print</span>&nbsp;<span class="wrd">baz.bar</span><span class="oth">(</span><span class="num">1</span><span class="oth">)</span><br />
</div></tt><br />
<br \>
This time, I've added a constructor and destructor, which will allocate and deallocate a dynamic memory array, x, with the number of elements specified in the constructor.  Then when the property functions are invoked, I check if the index is within the bounds of the array, if it is then I perform the requested get or set.  If the index specified is out of bounds, then 'Error 6' occurs, which is a way to abort the program with FB's 'out of bounds error', you could replace this with your own error handling routines.  Try this out, by changing the code 'baz.bar(1) = 42' to 'baz.bar(10) = 42', and you'll see it in action, as we specified only 10 elements (index 0-9)<br \>
<br \>
<b>Copy constructor.</b><br \>
<br \>
A copy constructor is a special type of constructor, that is used to make a copy from an existing object.  When you write code like this:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">foo</span><br />
<span class="oth">...</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="wrd">a</span><br />
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="wrd">b</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">a</span><br />
</div></tt><br />
<br \>
What happens is FreeBASIC automatically generates hidden code to construct b, by making a copy of a, this is the default copy constructor, and simply copies the data fields (members) across.  We can define our own copy constructor, here's just a brief snippet to show how we declare it.<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">foo</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span><span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">obj</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="oth">...</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
</div></tt><br />
<br \>
This will come in very useful for a reason I will now explain.<br \>
<br \>
<b>Deep/Shallow copy.</b><br \>
<br \>
In that previous example, where we did the code 'Dim As foo b = a', that was what is known a shallow copy, it just simply copied the data fields across, however sometimes this is not desirable, imagine that one of the members is a pointer, what will happen is that the address that pointer points to will be copied across, so both objects will point to the same memory.  An example of this follows:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">foo</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="key">Ptr</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="wrd">a</span><br />
<br />
<span class="wrd">a.x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">Allocate</span><span class="oth">(</span><span class="key">SizeOf</span><span class="oth">(</span><span class="key">Integer</span><span class="oth">))</span><br />
<span class="oth">*</span><span class="wrd">a.x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">42</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="wrd">b</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">a</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="oth">*</span><span class="wrd">a.x</span><span class="oth">,</span>&nbsp;<span class="oth">*</span><span class="wrd">b.x</span><br />
<br />
<span class="oth">*</span><span class="wrd">a.x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">420</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="oth">*</span><span class="wrd">a.x</span><span class="oth">,</span>&nbsp;<span class="oth">*</span><span class="wrd">b.x</span><br />
<br />
<span class="key">Deallocate</span><span class="oth">(</span><span class="wrd">a.x</span><span class="oth">)</span><br />
</div></tt><br />
<br \>
As you see, because they both point to the same memory, changing one affects the other.  As explained in the previous section on the copy constructor, FreeBASIC creates the code to do shallow copies by default.  This is also true if we do an assignment like:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="wrd">a</span><span class="oth">,</span>&nbsp;<span class="wrd">b</span><br />
<br />
<span class="wrd">b</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">a</span><br />
</div></tt><br />
<br \>
In this case also, FreeBASIC creates a default assignment operator (Let) to perform a shallow copy.  In order to do deep copies, we need to define a copy constructor, and an assignment operator, that is overloaded to accept our type.  Here's an example using them.<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">foo</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span><span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">obj</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Destructor</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="key">Let</span><span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">obj</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="key">Ptr</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Constructor</span>&nbsp;<span class="wrd">foo</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;Default&nbsp;ctor&quot;</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">CAllocate</span><span class="oth">(</span><span class="key">SizeOf</span><span class="oth">(</span><span class="key">Integer</span><span class="oth">))</span><br />
<span class="key">End</span>&nbsp;<span class="key">Constructor</span><br />
<br />
<span class="key">Constructor</span>&nbsp;<span class="wrd">foo</span><span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">obj</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;Copy&nbsp;ctor&quot;</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">CAllocate</span><span class="oth">(</span><span class="key">SizeOf</span><span class="oth">(</span><span class="key">Integer</span><span class="oth">))</span><br />
&nbsp;&nbsp;<span class="oth">*</span><span class="wrd">x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="oth">*</span><span class="wrd">obj.x</span><br />
<span class="key">End</span>&nbsp;<span class="key">Constructor</span><br />
<br />
<span class="key">Destructor</span>&nbsp;<span class="wrd">foo</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;dtor&quot;</span><br />
&nbsp;&nbsp;<span class="key">Deallocate</span><span class="oth">(</span><span class="wrd">x</span><span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Destructor</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="wrd">foo.Let</span><span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">obj</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;Let&quot;</span><br />
&nbsp;&nbsp;<span class="oth">*</span><span class="wrd">x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="oth">*</span><span class="wrd">obj.x</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="wrd">a</span><br />
<br />
<span class="oth">*</span><span class="wrd">a.x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">42</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="wrd">b</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">a</span>&nbsp;<span class="com">'Uses&nbsp;the&nbsp;copy&nbsp;constructor</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="oth">*</span><span class="wrd">a.x</span><span class="oth">,</span>&nbsp;<span class="oth">*</span><span class="wrd">b.x</span><br />
<br />
<span class="oth">*</span><span class="wrd">a.x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">420</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="oth">*</span><span class="wrd">a.x</span><span class="oth">,</span>&nbsp;<span class="oth">*</span><span class="wrd">b.x</span><br />
</div></tt><br />
<br \>
As you can see, the copy constructor gets called on the line 'Dim As foo b = a' and this time, we allocate some memory, and copy the data in the new copy constructor, so that we can adjust x in one object without it affecting the other.  If we change the main code as follows:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="wrd">a</span><span class="oth">,</span>&nbsp;<span class="wrd">b</span><br />
<br />
<span class="oth">*</span><span class="wrd">a.x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">42</span><br />
<span class="wrd">b</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">a</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="com">'The&nbsp;assignment&nbsp;operator&nbsp;(Let)&nbsp;gets&nbsp;used&nbsp;this&nbsp;time.</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="oth">*</span><span class="wrd">a.x</span><span class="oth">,</span>&nbsp;<span class="oth">*</span><span class="wrd">b.x</span><br />
<br />
<span class="oth">*</span><span class="wrd">a.x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">420</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="oth">*</span><span class="wrd">a.x</span><span class="oth">,</span>&nbsp;<span class="oth">*</span><span class="wrd">b.x</span><br />
</div></tt><br />
<br \>
Then this time the assignment operator is used. Note that in the assignment operator code, we don't need to allocate any memory because it has already been allocated in the default constructor, we just need to copy the data across.  The line '*x = *obj.x' performs this copy.  If we had something more advanced, like a dynamic memory array, then we would need to reallocate the memory to be the correct size to fit the data being copied.  Here's a more advanced version just to show that.<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">foo</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">num_elements</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span><span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">obj</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Destructor</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="key">Let</span><span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">obj</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="key">Ptr</span><br />
&nbsp;&nbsp;<span class="wrd">size</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Constructor</span>&nbsp;<span class="wrd">foo</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">num_elements</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;Default&nbsp;ctor&quot;</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">CAllocate</span><span class="oth">(</span><span class="key">SizeOf</span><span class="oth">(</span><span class="key">Integer</span><span class="oth">)</span>&nbsp;<span class="oth">*</span>&nbsp;<span class="wrd">num_elements</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="wrd">size</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">num_elements</span><br />
<span class="key">End</span>&nbsp;<span class="key">Constructor</span><br />
<br />
<span class="key">Constructor</span>&nbsp;<span class="wrd">foo</span><span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">obj</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;Copy&nbsp;ctor&quot;</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">CAllocate</span><span class="oth">(</span><span class="key">SizeOf</span><span class="oth">(</span><span class="key">Integer</span><span class="oth">)</span>&nbsp;<span class="oth">*</span>&nbsp;<span class="wrd">obj.size</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="wrd">size</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">obj.size</span><br />
&nbsp;&nbsp;<span class="key">For</span>&nbsp;<span class="wrd">i</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="key">To</span>&nbsp;<span class="wrd">size</span>&nbsp;<span class="oth">-</span>&nbsp;<span class="num">1</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="wrd">x</span><span class="oth">[</span><span class="wrd">i</span><span class="oth">]</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">obj.x</span><span class="oth">[</span><span class="wrd">i</span><span class="oth">]</span><br />
&nbsp;&nbsp;<span class="key">Next</span>&nbsp;<span class="wrd">i</span><br />
<span class="key">End</span>&nbsp;<span class="key">Constructor</span><br />
<br />
<span class="key">Destructor</span>&nbsp;<span class="wrd">foo</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;dtor&quot;</span><br />
&nbsp;&nbsp;<span class="key">Deallocate</span><span class="oth">(</span><span class="wrd">x</span><span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Destructor</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="wrd">foo.Let</span><span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">obj</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;Let&quot;</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">Reallocate</span><span class="oth">(</span><span class="wrd">x</span><span class="oth">,</span>&nbsp;<span class="key">SizeOf</span><span class="oth">(</span><span class="key">Integer</span><span class="oth">)</span>&nbsp;<span class="oth">*</span>&nbsp;<span class="wrd">obj.size</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="wrd">size</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">obj.size</span><br />
&nbsp;&nbsp;<span class="key">For</span>&nbsp;<span class="wrd">i</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="key">To</span>&nbsp;<span class="wrd">size</span>&nbsp;<span class="oth">-</span>&nbsp;<span class="num">1</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="wrd">x</span><span class="oth">[</span><span class="wrd">i</span><span class="oth">]</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">obj.x</span><span class="oth">[</span><span class="wrd">i</span><span class="oth">]</span><br />
&nbsp;&nbsp;<span class="key">Next</span>&nbsp;<span class="wrd">i</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="wrd">a</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">foo</span><span class="oth">(</span><span class="num">5</span><span class="oth">)</span><br />
<br />
<span class="wrd">a.x</span><span class="oth">[</span><span class="num">0</span><span class="oth">]</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">42</span><br />
<span class="wrd">a.x</span><span class="oth">[</span><span class="num">1</span><span class="oth">]</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">420</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="wrd">b</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">a</span>&nbsp;<span class="com">'Uses&nbsp;the&nbsp;copy&nbsp;constructor</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="wrd">a.x</span><span class="oth">[</span><span class="num">0</span><span class="oth">],</span>&nbsp;<span class="wrd">a.x</span><span class="oth">[</span><span class="num">1</span><span class="oth">],</span>&nbsp;<span class="wrd">b.x</span><span class="oth">[</span><span class="num">0</span><span class="oth">],</span>&nbsp;<span class="wrd">b.x</span><span class="oth">[</span><span class="num">1</span><span class="oth">]</span><br />
<br />
<span class="wrd">b.x</span><span class="oth">[</span><span class="num">0</span><span class="oth">]</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">10</span><br />
<span class="wrd">b.x</span><span class="oth">[</span><span class="num">1</span><span class="oth">]</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">20</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="wrd">a.x</span><span class="oth">[</span><span class="num">0</span><span class="oth">],</span>&nbsp;<span class="wrd">a.x</span><span class="oth">[</span><span class="num">1</span><span class="oth">],</span>&nbsp;<span class="wrd">b.x</span><span class="oth">[</span><span class="num">0</span><span class="oth">],</span>&nbsp;<span class="wrd">b.x</span><span class="oth">[</span><span class="num">1</span><span class="oth">]</span><br />
<br />
<span class="wrd">b</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">a</span>&nbsp;<span class="com">'&nbsp;Now&nbsp;using&nbsp;the&nbsp;assignment&nbsp;operator</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="wrd">a.x</span><span class="oth">[</span><span class="num">0</span><span class="oth">],</span>&nbsp;<span class="wrd">a.x</span><span class="oth">[</span><span class="num">1</span><span class="oth">],</span>&nbsp;<span class="wrd">b.x</span><span class="oth">[</span><span class="num">0</span><span class="oth">],</span>&nbsp;<span class="wrd">b.x</span><span class="oth">[</span><span class="num">1</span><span class="oth">]</span><br />
</div></tt><br />
<br \>
This may seem quite complex at first, it's worth just reading through it again, and experimenting with the examples, it's not too tricky once you're used to it.<br \>
<br \>
<b>Passing objects to functions ByVal</b><br \>
<br \>
The idea of deep and shallow copies also applies to passing an object to a function by value.  When you pass a reference to an object (ByRef), you can modify the object, and these modifications will persist, however you can also pass by value, which will mean you can modify it without the changes persisting outside of the function.  When an object is passed by value to a function, a new copy is created, and if that object has a copy constructor, then this is invoked, if it doesn't, then the hidden shallow copy is performed.  Once the function ends, the objects destructor is called.<br \>
<br \>
<b>New/Delete</b><br \>
<br \>
New and delete are special operators for dynamically allocating memory, then destroying it.  Because it is used with dynamic memory, it is used with pointers.  In all the examples up until now, we just used Dim to create our objects, this will create them on the stack, but by using new we can create them dynamically, which can allow more flexibility, just like using Allocate/DeAllocate with normal memory.  Another important thing about new, is that you don't need to check if the pointer is NULL after new, like you would if you did allocate.  If new fails, it causes an exception, which will end the program.  In later versions of FreeBASIC, it is likely that some kind of try..catch mechanism will be created to allow better exception handling, but as of the time of writing, this is not yet implemented.  <br \>
<br \>
There are two different varieties of the new/delete.  The first type, creates just a single element or object, for example:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">New</span>&nbsp;<span class="key">Integer</span><br />
<br />
<span class="oth">*</span><span class="wrd">foo</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">1</span><br />
<span class="key">Print</span>&nbsp;<span class="oth">*</span><span class="wrd">foo</span><br />
<br />
<span class="key">Delete</span>&nbsp;<span class="wrd">foo</span><br />
</div></tt><br />
<br \>
This will create a new Integer, then destroy it when we call delete.  Remember I used ptr, because it is dynamic memory.  For simple data types you can also specify a default value, by placing it in parenthesis after the data type, ie:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">New</span>&nbsp;<span class="key">Integer</span><span class="oth">(</span><span class="num">42</span><span class="oth">)</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="oth">*</span><span class="wrd">foo</span><br />
<br />
<span class="key">Delete</span>&nbsp;<span class="wrd">foo</span><br />
</div></tt><br />
<br \>
This also works for UDT's with just simple data fields:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">foo</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
&nbsp;&nbsp;<span class="wrd">y</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="wrd">bar</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">New</span>&nbsp;<span class="wrd">foo</span><span class="oth">(</span><span class="num">1</span><span class="oth">,</span>&nbsp;<span class="num">2</span><span class="oth">)</span><br />
&nbsp;&nbsp;<br />
<span class="key">Print</span>&nbsp;<span class="wrd">bar</span><span class="oth">-&gt;</span><span class="wrd">x</span><span class="oth">,</span>&nbsp;<span class="wrd">bar</span><span class="oth">-&gt;</span><span class="wrd">y</span><br />
<br />
<span class="key">Delete</span>&nbsp;<span class="wrd">bar</span><br />
</div></tt><br />
<br \>
This initialization won't work for more complex types involving constructors/destructors etc., however a useful feature is that when using new/delete with objects, it also calls the constructor and destructor, try the following example:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">foo</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Destructor</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
&nbsp;&nbsp;<span class="wrd">y</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Constructor</span>&nbsp;<span class="wrd">foo</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;ctor&quot;</span><br />
<span class="key">End</span>&nbsp;<span class="key">Constructor</span><br />
<br />
<span class="key">Destructor</span>&nbsp;<span class="wrd">foo</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;dtor&quot;</span><br />
<span class="key">End</span>&nbsp;<span class="key">Destructor</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="wrd">bar</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">New</span>&nbsp;<span class="wrd">foo</span><br />
<br />
<span class="key">Delete</span>&nbsp;<span class="wrd">bar</span><br />
</div></tt><br />
<br \>
You will see that the constructor and destructor for the object are called.<br \>
<br \>
The second type of new/delete is for creating arrays, this time the number of elements is placed after the dataype in square brackets '[]'.  When using the array version, you must also use 'delete[]' instead of 'delete', so that FreeBASIC knows you are deleting an array, here is a simple example using the Integer type:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">New</span>&nbsp;<span class="key">Integer</span><span class="oth">[</span><span class="num">20</span><span class="oth">]</span><br />
<br />
<span class="wrd">foo</span><span class="oth">[</span><span class="num">1</span><span class="oth">]</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">1</span><br />
<span class="key">Print</span>&nbsp;<span class="wrd">foo</span><span class="oth">[</span><span class="num">1</span><span class="oth">]</span><br />
<br />
<span class="key">Delete</span><span class="oth">[]</span>&nbsp;<span class="wrd">foo</span><br />
</div></tt><br />
<br \>
This will create a dynamic array, with 20 Integer elements.  It should be noted this is different from Allocate, which takes the number of bytes as its argument; using new, you should specify the number of elements.  The array method works just the same for objects:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">foo</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Destructor</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
&nbsp;&nbsp;<span class="wrd">y</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Constructor</span>&nbsp;<span class="wrd">foo</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;ctor&quot;</span><br />
<span class="key">End</span>&nbsp;<span class="key">Constructor</span><br />
<br />
<span class="key">Destructor</span>&nbsp;<span class="wrd">foo</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">&quot;dtor&quot;</span><br />
<span class="key">End</span>&nbsp;<span class="key">Destructor</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="wrd">bar</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">New</span>&nbsp;<span class="wrd">foo</span><span class="oth">[</span><span class="num">3</span><span class="oth">]</span><br />
<br />
<span class="key">Delete</span><span class="oth">[]</span>&nbsp;<span class="wrd">bar</span><br />
</div></tt><br />
<br \>
When you run this code, you will see that three constructor/destructor pairs are called, because we created an array of three instances of foo.<br \>
<br \>
You must remember to call Delete, or Delete[] for any memory allocated with New, or you will cause a memory leak, just like the way you must rememeber to call DeAllocate for any memory you allocate with the Allocate function.<br \>
<br \>
<b>Name Mangling</b><br \>
<br \>
Name mangling, also known as name decoration, is something that happens behind the scenes, at a lower level, and as such is not essential to know about.  The reason for name mangling is to resolve problems that are involved with more than one function sharing the same name, which happens when functions are overloaded, or are part of a type.  Take for example the overloaded subs shown below:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Sub</span>&nbsp;<span class="wrd">foo</span>&nbsp;<span class="key">Overload</span>&nbsp;<span class="oth">()</span><br />
<br />
<span class="key">End</span>&nbsp;<span class="key">Sub</span><br />
<br />
<span class="key">Sub</span>&nbsp;<span class="wrd">foo</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">i</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
<br />
<span class="key">End</span>&nbsp;<span class="key">Sub</span><br />
</div></tt><br />
<br \>
If we didn't have name mangling, then both might be known at a lower level as FOO, which would cause a name clash, so they have to be decorated in order to know which one should be called when they are used.  For the first sub, the compiler actually creates a sub called _Z3FOOv, and for the second it creates a sub called _Z3FOOi.  The compiler then remembers these, and chooses the appropriate sub to call, depending on how you call it, for example 'foo()' will actually call _Z3FOOv, and 'foo(1)' will actually call _Z3FOOi.  We can spot something from this, that the 'v' stands for void (no argument), and 'i' stands for integer.  The full details of name mangling are quite complex, and vary between compilers, the Microsoft compilers use a different name mangling scheme to GNU compilers, and other compilers may use different schemes as well.  The main thing we need to know, is that FreeBASIC follows the GCC 3.x ABI (Application binary interface), meaning that any overloaded functions, or complex types will only be compatible with other compilers using the same scheme.  This is an unfortunate limitation, but it is not really a FreeBASIC problem, it is common of all the compilers that use advanced features, and even if all the compiler authors agreed on a common name mangling scheme, there are still other issues that would cause incompatability.<br \>
<br \>
<b>Implicit this</b><br \>
<br \>
This again is not necessary to know about mostly, its something that happens behind the scenes at a lower level.  When you call a member function of an object, what actually happens is a hidden first parameter is passed, so that the function knows which instance of the object is being refered to.  This is also true for the property/constructor/destructor/operator members.  If we look at a very simple example:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">foo</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Sub</span>&nbsp;<span class="wrd">bar</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">n</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Sub</span>&nbsp;<span class="wrd">foo.bar</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">n</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">n</span><br />
<span class="key">End</span>&nbsp;<span class="key">Sub</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="wrd">baz</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span><br />
<span class="wrd">baz.bar</span><span class="oth">(</span><span class="num">5</span><span class="oth">)</span><br />
</div></tt><br />
<br \>
What actually happens behind the scenes is something essentially equivalent to this:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">foo</span><br />
&nbsp;&nbsp;<span class="wrd">x</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Sub</span>&nbsp;<span class="wrd">foo_bar</span><span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">_this</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span><span class="oth">,</span>&nbsp;<span class="key">ByVal</span>&nbsp;<span class="wrd">n</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="wrd">_this.x</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">n</span><br />
<span class="key">End</span>&nbsp;<span class="key">Sub</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="wrd">baz</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">foo</span><br />
<span class="wrd">foo_bar</span><span class="oth">(</span><span class="wrd">baz</span><span class="oth">,</span>&nbsp;<span class="num">5</span><span class="oth">)</span><br />
</div></tt><br />
<br \>
This method using an explicit 'this' is often used in languages that do not have facilities to make it easier.  OOP is really just a set of concepts, that can be mostly coded in almost any language, some things are more difficult to implement, such as constructors, you would have to explicitly call a 'create', or 'init' function.  For some things such as private/public distinction, it is even more difficult or impossible because the compiler does not know to enforce them.  The reason for adding OOP features to a language is to hide a lot of this, and add syntactic sugar to make it simpler to do, or more transparent in use, such as the way we can use properties as if they were ordinary data members, rather than functions, which is what they really are.<br \>
<br \>
<b>Hints for debugging/profiling</b><br \>
<br \>
When using GDB or other debuggers, and the gprof profiling tool, the information shown is in the C++ syntax, and all your variable names and other symbols are shown in upper case, here is just a very short overview to help you understand how these are shown:<br \>
<br \>
Here's an example type:<br \>
<br \>
<tt><div class="freebasic">
<span class="key">Type</span>&nbsp;<span class="wrd">bar</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span><span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">obj</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">bar</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">n</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Destructor</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="key">Cast</span><span class="oth">()</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Any</span>&nbsp;<span class="key">Ptr</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="key">Let</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">n</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Property</span>&nbsp;<span class="wrd">foo</span><span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">n</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Property</span>&nbsp;<span class="wrd">foo</span><span class="oth">()</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span><br />
&nbsp;&nbsp;<span class="wrd">member</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Any</span>&nbsp;<span class="key">Ptr</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
</div></tt><br />
<br \>
When using GDB, these will be shown as follows (note in C++ they use :: where we would use . (dot), '::' is known as the scope resolution operator):<br \>
<br \>
  BAR::BAR()            - The default constructor<br \>
  BAR::BAR(BAR&)        - The copy constructor (& in C++ means a reference, like byref)<br \>
  BAR::BAR(int)         - The constructor taking an integer argument (note there is no special symbol to denote ByVal, as this is the default passing method in C/C++)<br \>
  BAR::~BAR()           - The destructor<br \>
  BAR::operator void*() - A cast to Any ptr (void is similar to Any, * means pointer)<br \>
  BAR::operator=(int)   - The assignment operator (Let), dentoted by '=', in C/C++ '=' is assignment, '==' is equality testing.<br \>
  BAR::FOO(int)         - Property foo setter, taking an integer argument<br \>
  BAR::FOO()            - Property foo getter<br \>
<br \>
Member sub/functions are shown in the same way as properties, indexed properties are shown the same also, just with the extra argument for the index.<br \>
<br \>
Here is how the FB data types will be shown:<br \>
<br \>
Any ptr     - void *<br \>
ZString ptr - char *<br \>
String      - FBSTRING<br \>
byte        - signed char<br \>
ubyte       - bool<br \>
short       - short<br \>
ushort      - unsigned short<br \>
integer     - int<br \>
uinteger    - unsigned int<br \>
longint     - long long<br \>
ulongint    - unsigned long long<br \>
<br \>
I hope that helps you get started with understanding how things are displayed in GDB/gprof, a little experimentation will always help.<br \>
<br \>
<b>More reading</b><br \>
<br \>
http://www.freebasic.net/wiki/wikka.php?wakka=KeyPgOpNew<br \>
http://www.freebasic.net/wiki/wikka.php?wakka=KeyPgOpDelete<br \>
http://en.wikipedia.org/wiki/Copy_constructor<br \>
http://en.wikipedia.org/wiki/Object_copy<br \>
http://en.wikipedia.org/wiki/Name_mangling<br \>
<br \>
<i>Last Reviewed by Sancho3 on February 06, 2018</i>
</div>
</div> 
</div> 
</body>
</html>
